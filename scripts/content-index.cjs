const fs = require("fs");
const path = require("path");
const { validateCrisis } = require("./content-schemas.cjs");

const root = process.cwd();
const crisesDir = path.join(root, "content", "crises");
const outputDir = path.join(root, "src", "generated");
const outputFile = path.join(outputDir, "contentIndex.ts");

const ensureDir = (dir) => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
};

const readManifestFiles = (dir) => {
  if (!fs.existsSync(dir)) return [];
  const manifests = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const target = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      manifests.push(...readManifestFiles(target));
      continue;
    }
    if (entry.isFile() && entry.name.startsWith("manifest.") && entry.name.endsWith(".json")) {
      manifests.push({
        slug: path.basename(path.dirname(target)) || null,
        lang: entry.name.split(".")[1],
        path: target,
        data: JSON.parse(fs.readFileSync(target, "utf-8")),
      });
    }
  }
  return manifests;
};

const rawManifests = readManifestFiles(crisesDir);
const bySlug = new Map();

rawManifests.forEach((item) => {
  const key = item.slug || item.data.slug || "unknown";
  const existing = bySlug.get(key);
  if (!existing) {
    bySlug.set(key, item);
    return;
  }
  if (existing.lang === "en" && item.lang === "de") {
    bySlug.set(key, item);
  }
});

const crisisFiles = Array.from(bySlug.values()).filter(({ data }) => typeof data.id === "string");
if (crisisFiles.length === 0) {
  console.warn("No canonical crisis entries found in content/crises – skipping index generation.");
}
const crises = crisisFiles
  .map(({ path: filePath, data }) => {
    const validation = validateCrisis(data);
    if (!validation.valid) {
      console.error(`❌ Crisis schema errors in ${filePath}:`);
      validation.errors.forEach((err) => {
        console.error(`  ${err.path}: ${err.message}`);
      });
      process.exit(1);
    }
    return data;
  })
  .sort((a, b) => a.id.localeCompare(b.id));

const tagMap = {};
const layerMap = {};
const searchIndex = crises.map((entry) => {
  const tokens = Array.from(
    new Set(
      `${entry.title_de} ${entry.short_definition_de} ${entry.long_analysis_de} ${entry.tags.join(" ")}`
        .toLowerCase()
        .split(/\\W+/)
        .filter(Boolean),
    ),
  );
  entry.tags.forEach((tag) => {
    const normalized = tag.toLowerCase();
    tagMap[normalized] = Array.from(new Set([...(tagMap[normalized] || []), entry.id]));
  });
  layerMap[entry.layer] = Array.from(new Set([...(layerMap[entry.layer] || []), entry.id]));
  return { id: entry.id, tokens };
});

const contentIndex = {
  crises,
  tags: Object.fromEntries(Object.entries(tagMap).map(([tag, list]) => [tag, list.sort()])),
  layers: Object.fromEntries(Object.entries(layerMap).map(([layer, list]) => [layer, list.sort()])),
  searchIndex,
};

ensureDir(outputDir);
const fileContent =
  "// generated by scripts/content-index.js\n" + `export const contentIndex = ${JSON.stringify(contentIndex, null, 2)};\n`;
fs.writeFileSync(outputFile, fileContent);
console.log(`Content index written to ${outputFile} (${crises.length} items).`);
